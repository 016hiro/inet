- attach IPDatagram to IPControlInfo..? and fix UDP.

- TCP: TCPConnectionEventProc.cc 204: when the user issues CLOSE, we 
  transition to this FIN_WAIT_1. It should in theory be deferred until we 
  actually send the FIN segment, but does no harm to do it that way.

- BUG: UDP ephemeral port setting: if chosen & stored in UDP, sending further dgrams need to look it up from the SockDesc...

--------
- "make dist"?

- TCP, UDP, LDP, RSVP, TED: rename gates...

- reading routing files: it doesn't make sense to be able to manually set MULTICAST on an interface

- create example network with both Ethernet and PPP


- IP/IPv6: implement tunnelling

- revise fragmentation in IP

- added userId to TCPCommand -- rewrite TCPSocketMap to make use of userId 
        - socket must be inserted into map before bind(), so that a userId can be assigned
        - what about incoming connections? how to assign userId to them?
           IF IT CANNOT BE DONE: remove userId from TCP!!!!

- TCP/UDP: unspec port should be 0 not -1!!!

- NAM trace: doesn't record drops, because DropTailQueue doesn't send notifications

- ThruputMeteringChannel could integrate PPP/ThruputMeter code, for momentary thruput measurement

- there's no IPAddress::getPrefix() and getSuffix() (like IPv6Address has)

- apps: add startTime param; IPAddressResolver should only be invoked at startTime not in initialize()!

- TCP tests fail now (TCPDump has changed)

- if a node pings itself, that'll be "destination unreachable" -- fix it

- Eth: restore original conn color when transmission ends

- "headerLength" param in snrEval???

- IPv4 configurator: should fill in next hop addresses too, not only interface (esp with Ethernet)

- rename TCPBasicClientApp to TCPRequestReplyClientApp ?

- IPv4: make it usable with ad-hoc models

- notifboard: switch to the context of the client before calling its receiveNotification()

- doxy: turn on generation of "called/referenced from" links

- implement class PacketQueue : public cQueue

- add more notifications (NotificationBoard): interface up/down, routing table change, etc
- todo for omnetpp-3.2:
     - add handleParameterChange() to apps (needed for Scenario Manager!)
     - makemakefiles: -P option
     - use new opp_msgc features? (kind=..., length=...etc)

----------------------- 
Note: existing other 802.11 models:
- from CATALA MONZO ANGEL
- from MAGNUS KARLSSON
-----------------------
Interfaces:
- IPv6RoutingTable: change _interfaceId to _ie!!!

- interfaceAt -> interfaceById!!!

- store interfaces in an std::map<int,InterfaceEntry*> inside interfaceTable! 
  - this makes it possible to implement interface deletion as well, with preserving ids;
  - or just use a vector like for gates and modules? (apps must check for holes then!)
- notify when an interface gets deleted -- the RoutingTable, ARP etc should remove associated entries

-----------------------
- MPLS/LDP/RSVP: 
    - document! ScenarioManager commands, XML file formats, unimplemented features
    - split TED to TED+LinkStateRouting !
    - Quagga ospfd: could it serve as OSPF_TE??
- mpls models use interface NAME - why?

-----------------------
- OSPFv2 TODO: 
     - should use the proper IPAddress class, not its own one...
     - OSPFTimer class only contains a timerKind() -- is this class necessary at all...?
     - rename ifIndex (SetIfIndex, GetIfIndex, etc) to interfaceId AND change default value to -1!
     - OSPFRouting::LoadInterfaceParameters: interfaceType is contained in InterfaceEntry, it's redundant to read it from XML!
     - try to reduce size of configuration. If Zebra can do it...
----------------------- 
into the ipv6 doc:
"
Currently, IPv6 support consists of several modules. The IPv6 module
implements IPv6 datagram handling (sending, forwarding etc). It relies on
RoutingTable6 to get access to the routes. RoutingTable6 also contains the
neighbour discovery data structures (dest cache, neighbour cache, prefix
list -- the latter effectively merged into the route table). Interface
configuration (address, state, timeouts etc) is held in the InterfaceTable,
in IPv6InterfaceData objects attached to InterfaceEntry as its ipv6()
member.

The module IPv6NeighbourDiscovery implements all tasks associated with
neighbour discovery and stateless address autoconfiguration. Its data
structures are in RoutingTable6 (dest cache, neighbour cache, prefix list).
Neighbour discovery packets are only sent and processed by this module --
when IPv6 receives one, it forwards the packet to IPv6NeighbourDiscovery.

The rest of ICMPv6 (ICMP errors, echo request/reply etc) is implemented in
the module ICMPv6, just like with IPv4. ICMP errors are sent into
IPv6ErrorHandling, which the user can extend or replace to get errors
handled in any way they like.
"

----------------------- 
TCP BUG:
From: Joachim Meichle [mailto:joachim.meichle@stud.uni-karlsruhe.de] 
Sent: Sunday, September 25, 2005 7:51 PM
To: omnetpp-l@omnetpp.org
Subject: [omnetpp] Incorrect behaviour of TCP in IPv6SuiteWithINET(2005-05-02)?

Hi!

I found something that seems to be a bug in TCPMain:

I open a TCP-Connection with TCPSocket and send a message (let's call it "A") 
trough it. This happens: "ActiveOPEN" is sent to TCPMain, followed by 
message A. Message A is buffered (according to RFC 793) an the 3-way-handshake 
starts. The last message of the 3-way-handshake (ACK) already carries 
message A (piggybacking). So far so good. The receiver then changes state 
from SYN-RECEIVED to ESTABLISHED but doesn't' forward message A to the upper 
layer. Instead the sender waits 3 seconds for timeout and resends message A, 
which is then successfully delivered to the receiver's application (and ACKed).

IMO the receiver behaves wrong. In accordance to RFC 793 (Page 73: 
"If SND.UNA =< SEG.ACK =< SND.NXT then enter ESTABLISHED state and continue 
processing"), it should change state from SYN-RECEIVED to ESTABLISHED _and_ 
continue processing in the new state and forward the attached message A to 
application.

Is this really a bug in TCPMain or did I miss something? If it is a bug: is 
it fixed in newer releases?

The interesting part of my code is the following:
> TCPSocket socket;
> cMessage *msg;
> [...]
> socket.setOutputGate(gate("tcpOut"));
> [..]
> socket.connect(IPAddressResolver ().resolve("aaas/ppp0"),3868); 
> socket.send(msg);
(no "socket.close")

Regards,
Joachim


----------------------- 
VOJTA: 
2. Some minor changes in INET are required

* bind mechanism in both TCP/UDP should be generalized
 -bind to address:port not just port
 -Ripd (others may too, I didn't check) uses multicast and binds several 
sockets to the same UDP address/port  (this is possible using 
SO_REUSEADDR and SO_REUSEPORT)
 -moreover, there exist multiple UDP sockets at the same time and it 
probably makes sense to demultiplex incoming packets at the transport 
layer, not in application (e.g. by using user supplied identifier on bind)
 -make connect work without bind (autoassign local address based on 
destination, currently unspecified address is sent and SYN+ACK will not 
be sent back (at least for 127.0.0.1, I didn't check for others))
 -UDPSocket similar to TCPSocket would be helpful
