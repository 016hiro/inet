diff --git a/Makefile.inc.in b/Makefile.inc.in
index 75bc1ad..e21a131 100644
--- a/Makefile.inc.in
+++ b/Makefile.inc.in
@@ -8,6 +8,9 @@ OMNETPP_VERSION = @OMNETPP_VERSION@
 OMNETPP_BUILDID = @OMNETPP_BUILDID@
 OMNETPP_EDITION = @OMNETPP_EDITION@
 
+# variable to show that the message compiler has a temporary patch applied
+OMNETPP_MSGC_PATCH_VER = 1
+
 #
 # Optional features (set to "yes" to enable the feature)
 #
diff --git a/include/omnetpp/cmessage.h b/include/omnetpp/cmessage.h
index c68f739..db6fc73 100644
--- a/include/omnetpp/cmessage.h
+++ b/include/omnetpp/cmessage.h
@@ -295,7 +295,7 @@ class SIM_API cMessage : public cEvent
      * does not define dup/copy operations.
      * The assignment operator does not change control info.
      */
-    void setControlInfo(cObject *p);
+    virtual void setControlInfo(cObject *p);
 
     /**
      * Removes the "control info" structure (object) from the message
diff --git a/include/omnetpp/cobject.h b/include/omnetpp/cobject.h
index 70db509..5a356d1 100644
--- a/include/omnetpp/cobject.h
+++ b/include/omnetpp/cobject.h
@@ -82,6 +82,8 @@ class SIM_API cObject
     // internal
     virtual void yieldOwnership(cOwnedObject *obj, cObject *to);
 
+    virtual void handleChange() {};
+
   public:
     /**
      * Constructor. It has an empty body. (The class does not have data members
diff --git a/src/nedxml/msgcppgenerator.cc b/src/nedxml/msgcppgenerator.cc
index 8bb700a..a8076c8 100644
--- a/src/nedxml/msgcppgenerator.cc
+++ b/src/nedxml/msgcppgenerator.cc
@@ -133,6 +133,7 @@ P check_and_cast(T *p)
 
 MsgCppGenerator::TypeDesc MsgCppGenerator::_PRIMITIVE_TYPES[] =
 { //     nedTypeName        cppTypeName        fromstring            tostring               emptyValue
+        {"bit",             "bit",             "bit(string2long($))","long2string($.get())","bit(0)"},
         {"bool",            "bool",            "string2bool($)",     "bool2string($)",      "false"},
         {"float",           "float",           "string2double($)",   "double2string($)",    "0"},
         {"double",          "double",          "string2double($)",   "double2string($)",    "0"},
@@ -212,6 +213,8 @@ MsgCppGenerator::MsgCppGenerator(NEDErrorStore *e, const MsgCppGeneratorOptions&
     classType["omnetpp::cOwnedObject"] = COWNEDOBJECT;
     classType["omnetpp::cMessage"] = COWNEDOBJECT;
     classType["omnetpp::cPacket"] = COWNEDOBJECT;
+    classType["omnetpp::cModule"] = COWNEDOBJECT;
+    // TODO: others?
 }
 
 MsgCppGenerator::~MsgCppGenerator()
@@ -495,6 +498,7 @@ void MsgCppGenerator::generate(MsgFileElement *fileElement)
 
     CC << "#include <iostream>\n";
     CC << "#include <sstream>\n";
+    CC << "#include <memory>\n";
     CC << "#include \"" << hfilenamewithoutdir << "\"\n\n";
 
     CC << PARSIMPACK_BOILERPLATE;
@@ -723,8 +727,8 @@ void MsgCppGenerator::prepareFieldForCodeGeneration(ClassInfo& info, ClassInfo::
     }
 
     if (info.generate_class) {
-        if (it->classtype == COWNEDOBJECT && info.classtype != COWNEDOBJECT) {
-            errors->addError(it->nedElement, "cannot use cOwnedObject field '%s %s' in struct or non-cOwnedObject class '%s'\n", it->ftype.c_str(), it->fname.c_str(), info.msgname.c_str());
+        if (it->classtype == COWNEDOBJECT && !(info.classtype == COBJECT || info.classtype == CNAMEDOBJECT || info.classtype == COWNEDOBJECT)) {
+            errors->addError(it->nedElement, "cannot use cOwnedObject field '%s %s' in struct or non-cObject class '%s'\n", it->ftype.c_str(), it->fname.c_str(), info.msgname.c_str());
         }
     }
 
@@ -732,6 +736,8 @@ void MsgCppGenerator::prepareFieldForCodeGeneration(ClassInfo& info, ClassInfo::
     it->feditable = getPropertyAsBool(it->fprops, "editable", false);
     it->editNotDisabled = getPropertyAsBool(it->fprops, "editable", true);
     it->fopaque = getPropertyAsBool(it->fprops, "opaque", false);
+    it->overrideGetter = getPropertyAsBool(it->fprops, "overridegetter", false) || getPropertyAsBool(it->fprops, "override", false);
+    it->overrideSetter = getPropertyAsBool(it->fprops, "overridesetter", false) || getPropertyAsBool(it->fprops, "override", false);
     it->tostring = getProperty(it->fprops, "tostring", "");
     it->fromstring = getProperty(it->fprops, "fromstring", "");
 
@@ -950,6 +956,8 @@ void MsgCppGenerator::prepareForCodeGeneration(ClassInfo& info)
         info.fieldnamesuffix = "_var";
     }
 
+    info.declareStrFunction = getPropertyAsBool(info.props, "str", false);
+
     std::string s = getProperty(info.props, "implements");
     if (!s.empty()) {
         info.implements = StringTokenizer(s.c_str(), ",").asVector();
@@ -1112,6 +1120,9 @@ void MsgCppGenerator::generateClass(const ClassInfo& info)
     else {
         H << "    virtual " << info.msgclass << " *dup() const override {return new " << info.msgclass << "(*this);}\n";
     }
+    if (info.declareStrFunction) {
+        H << "    virtual std::string str() const override;\n";
+    }
     H << "    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;\n";
     H << "    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;\n";
     H << "\n";
@@ -1120,29 +1131,31 @@ void MsgCppGenerator::generateClass(const ClassInfo& info)
         std::string pure;
         if (it->fisabstract)
             pure = " = 0";
+        std::string overrideGetter(it->overrideGetter ? " override" : "");
+        std::string overrideSetter(it->overrideSetter ? " override" : "");
 
         bool isstruct = !it->fisprimitivetype;
         std::string constifprimitivetype = (!isstruct ? " const" : "");
         if (it->fisarray && !it->farraysize.empty()) {
             H << "    virtual " << it->fsizetype << " " << it->getsize << "() const" << pure << ";\n";
-            H << "    virtual " << it->rettype << " " << it->getter << "(" << it->fsizetype << " k)" << constifprimitivetype << "" << pure << ";\n";
+            H << "    virtual " << it->rettype << " " << it->getter << "(" << it->fsizetype << " k)" << constifprimitivetype << "" << pure << overrideGetter << ";\n";
             if (isstruct)
-                H << "    virtual const " << it->rettype << " " << it->getter << "(" << it->fsizetype << " k) const {return const_cast<" << info.msgclass << "*>(this)->" << it->getter << "(k);}\n";
-            H << "    virtual void " << it->setter << "(" << it->fsizetype << " k, " << it->argtype << " " << it->argname << ")" << pure << ";\n";
+                H << "    virtual const " << it->rettype << " " << it->getter << "(" << it->fsizetype << " k) const " << overrideGetter << " {return const_cast<" << info.msgclass << "*>(this)->" << it->getter << "(k);}\n";
+            H << "    virtual void " << it->setter << "(" << it->fsizetype << " k, " << it->argtype << " " << it->argname << ")" << pure << overrideSetter << ";\n";
         }
         else if (it->fisarray && it->farraysize.empty()) {
             H << "    virtual void " << it->alloc << "(" << it->fsizetype << " size)" << pure << ";\n";
             H << "    virtual " << it->fsizetype << " " << it->getsize << "() const" << pure << ";\n";
-            H << "    virtual " << it->rettype << " " << it->getter << "(" << it->fsizetype << " k)" << constifprimitivetype << "" << pure << ";\n";
+            H << "    virtual " << it->rettype << " " << it->getter << "(" << it->fsizetype << " k)" << constifprimitivetype << "" << pure << overrideGetter << ";\n";
             if (isstruct)
-                H << "    virtual const " << it->rettype << " " << it->getter << "(" << it->fsizetype << " k) const {return const_cast<" << info.msgclass << "*>(this)->" << it->getter << "(k);}\n";
-            H << "    virtual void " << it->setter << "(" << it->fsizetype << " k, " << it->argtype << " " << it->argname << ")" << pure << ";\n";
+                H << "    virtual const " << it->rettype << " " << it->getter << "(" << it->fsizetype << " k) const" << overrideGetter << " {return const_cast<" << info.msgclass << "*>(this)->" << it->getter << "(k);}\n";
+            H << "    virtual void " << it->setter << "(" << it->fsizetype << " k, " << it->argtype << " " << it->argname << ")" << pure << overrideSetter << ";\n";
         }
         else {
-            H << "    virtual " << it->rettype << " " << it->getter << "()" << constifprimitivetype << "" << pure << ";\n";
+            H << "    virtual " << it->rettype << " " << it->getter << "()" << constifprimitivetype << "" << pure << overrideGetter << ";\n";
             if (isstruct)
-                H << "    virtual const " << it->rettype << " " << it->getter << "() const {return const_cast<" << info.msgclass << "*>(this)->" << it->getter << "();}\n";
-            H << "    virtual void " << it->setter << "(" << it->argtype << " " << it->argname << ")" << pure << ";\n";
+                H << "    virtual const " << it->rettype << " " << it->getter << "() const" << overrideGetter << " {return const_cast<" << info.msgclass << "*>(this)->" << it->getter << "();}\n";
+            H << "    virtual void " << it->setter << "(" << it->argtype << " " << it->argname << ")" << pure << overrideSetter << ";\n";
         }
     }
     H << "};\n\n";
@@ -1410,6 +1423,7 @@ void MsgCppGenerator::generateClass(const ClassInfo& info)
                 CC << "}\n\n";
                 CC << "void " << info.msgclass << "::" << it->setter << "(" << it->fsizetype << " k, " << it->argtype << " " << it->argname << ")\n";
                 CC << "{\n";
+                CC << "    handleChange();\n";
                 CC << "    if (k>=" << it->farraysize << ") throw omnetpp::cRuntimeError(\"Array of size " << it->farraysize << " indexed by %lu\", (unsigned long)k);\n";
                 CC << "    this->" << it->var << "[k] = " << it->argname << ";\n";
                 CC << "}\n\n";
@@ -1417,6 +1431,7 @@ void MsgCppGenerator::generateClass(const ClassInfo& info)
             else if (it->fisarray && it->farraysize.empty()) {
                 CC << "void " << info.msgclass << "::" << it->alloc << "(" << it->fsizetype << " size)\n";
                 CC << "{\n";
+                CC << "    handleChange();\n";
                 CC << "    " << it->datatype << " *" << it->var << "2 = (size==0) ? nullptr : new " << it->datatype << "[size];\n";
                 CC << "    " << it->fsizetype << " sz = " << it->varsize << " < size ? " << it->varsize << " : size;\n";
                 CC << "    for (" << it->fsizetype << " i=0; i<sz; i++)\n";
@@ -1444,6 +1459,7 @@ void MsgCppGenerator::generateClass(const ClassInfo& info)
                 CC << "}\n\n";
                 CC << "void " << info.msgclass << "::" << it->setter << "(" << it->fsizetype << " k, " << it->argtype << " " << it->argname << ")\n";
                 CC << "{\n";
+                CC << "    handleChange();\n";
                 CC << "    if (k>=" << it->varsize << ") throw omnetpp::cRuntimeError(\"Array of size %d indexed by %d\", " << it->varsize << ", k);\n";
                 CC << "    this->" << it->var << "[k] = " << it->argname << ";\n";
                 CC << "}\n\n";
@@ -1455,6 +1471,7 @@ void MsgCppGenerator::generateClass(const ClassInfo& info)
                 CC << "}\n\n";
                 CC << "void " << info.msgclass << "::" << it->setter << "(" << it->argtype << " " << it->argname << ")\n";
                 CC << "{\n";
+                CC << "    handleChange();\n";
                 CC << "    this->" << it->var << " = " << it->argname << ";\n";
                 CC << "}\n\n";
             }
@@ -2005,7 +2022,7 @@ void MsgCppGenerator::generateDescriptorClass(const ClassInfo& info)
             }
             cast = "(void *)";
             if (field.classtype == COBJECT || field.classtype == CNAMEDOBJECT || field.classtype == COWNEDOBJECT)
-                cast = cast + "static_cast<omnetpp::cObject *>";
+                cast = cast + "static_cast<const omnetpp::cObject *>";
             if (field.fispointer) {
                 CC << "        case " << i << ": return " << cast << "(" << value << "); break;\n";
             }
@@ -2222,6 +2239,10 @@ void MsgCppGenerator::generateTemplates()
     CC << "template<typename T, typename A>\n";
     CC << "std::ostream& operator<<(std::ostream& out, const std::vector<T,A>& vec);\n\n";
 
+    CC << "// Template rule which fires if a shared_ptr doesn't have operator<<\n";
+    CC << "template<typename T>\n";
+    CC << "inline std::ostream& operator<<(std::ostream& out,const std::shared_ptr<T>& t) { return out << t.get(); }\n\n";
+
     CC << "// Template rule which fires if a struct or class doesn't have operator<<\n";
     CC << "template<typename T>\n";
     CC << "inline std::ostream& operator<<(std::ostream& out,const T&) {return out;}\n\n";
diff --git a/src/nedxml/msgcppgenerator.h b/src/nedxml/msgcppgenerator.h
index 76c74d4..7c2896b 100644
--- a/src/nedxml/msgcppgenerator.h
+++ b/src/nedxml/msgcppgenerator.h
@@ -151,6 +151,8 @@ class NEDXML_API MsgCppGenerator
             bool feditable;         // @editable(true)
             bool editNotDisabled;   // true when field doesn't have property "@editable(false)"
             bool fopaque;         // @opaque(true)        // TODO: @opaque should rather be the attribute of the field's type, not the field itself
+            bool overrideGetter;   // @overridegetter|@override, uses when field getter function overrides a function in base class
+            bool overrideSetter;   // @overridesetter|@override, uses when field setter function overrides a function in base class
 
           public:
             FieldInfo() : nedElement(nullptr), fisabstract(false), fispointer(false), fisarray(false), classtype(UNKNOWN), fnopack(false), feditable(false),fopaque(false) {}
@@ -165,6 +167,7 @@ class NEDXML_API MsgCppGenerator
 
         bool gap;                   // true if @customize
         bool omitgetverb;
+        bool declareStrFunction;
         ClassType classtype;
         std::string msgclass;
         std::string realmsgclass;
diff --git a/src/sim/cobject.cc b/src/sim/cobject.cc
index 1ad1139..792da20 100644
--- a/src/sim/cobject.cc
+++ b/src/sim/cobject.cc
@@ -113,8 +113,9 @@ void cObject::dropAndDelete(cOwnedObject *obj)
     if (!obj)
         return;
     if (obj->owner != this)
-        throw cRuntimeError(this, "dropAndDelete(): Not owner of object (%s)%s",
-                obj->getClassName(), obj->getFullPath().c_str());
+        throw cRuntimeError(this, "dropAndDelete(): Not owner of object (%s)%s, owner is (%s)%s",
+                obj->getClassName(), obj->getFullPath().c_str(),
+                obj->owner->getClassName(), obj->owner->getFullPath().c_str());
     obj->owner = nullptr;
     delete obj;
 }
diff --git a/src/sim/cpacket.cc b/src/sim/cpacket.cc
index 5af9519..ea5f688 100644
--- a/src/sim/cpacket.cc
+++ b/src/sim/cpacket.cc
@@ -249,6 +249,9 @@ void cPacket::encapsulate(cPacket *msg)
             throw cRuntimeError(this, "encapsulate(): Not owner of message (%s)%s, owner is (%s)%s",
                     msg->getClassName(), msg->getFullName(),
                     msg->getOwner()->getClassName(), msg->getOwner()->getFullPath().c_str());
+        if (msg->getBitLength() < 0)
+            throw cRuntimeError(this, "encapsulate(): negative length (%" PRId64 ") in message (%s)%s",
+                    msg->getBitLength(), msg->getClassName(), msg->getFullName());
         take(encapsulatedPacket = msg);
 #ifdef REFCOUNTING
         ASSERT(encapsulatedPacket->shareCount == 0);
diff --git a/src/sim/sim_std.msg b/src/sim/sim_std.msg
index dd77034..d3bc318 100644
--- a/src/sim/sim_std.msg
+++ b/src/sim/sim_std.msg
@@ -285,7 +285,7 @@ class cMessage extends cEvent
     long treeId @group("message") @hint("Identifier shared between the message and its copies");
     short kind @group("message") @editable @hint("Generic user-settable attribute, usually carries \"type\" or \"role\" or \"category\" of message");
     string displayString @group("message") @hint("Controls appearance of the message in GUI");
-    cObject *tags[] @getter(getTag) @sizeGetter(getNumTags) @group("message") @hint("Pieces of metadata attached to the message");
+    cObject *tags[] @getter(getTag) @sizeGetter(getNumTags) @hint("Pieces of metadata attached to the message");
     cObject *controlInfo @hint("Used with protocol stacks: carries extra information when a packet is sent between protocol layers");
     cArray *parList @getter(getParListPtr) @group("message") @hint("OBSOLETE: use of \"parList\" should be replaced with message subclassing in the few models that still use it");
